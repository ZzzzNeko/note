# 正则表达式

## 创建

`/source/flags` 或 `new RegExp(source[, flags])`

- `source`: 正则表达式文本
- `flags`: 修饰符，多个修饰符可以任意组合，取值如下
  - `g`: 全局匹配，即查找所有匹配，而不是找到第一个匹配后停止
  - `i`: 忽略大小写
  - `m`: 多行，将 `^` 和 `$` 规则应用在多行的每一行中
  - `u`: Unicode
  - `y`: 粘性匹配，仅匹配目标字符串中此正则表达式的 lastIndex 属性指示的索引(并且不尝试从任何后续的索引匹配)。

## 属性

- `reg.source <string>`: 正则表达式文本部分，即 `source` 参数
- `reg.flags <string>`: 正则表达式修饰符部分，即 `flags` 参数
- `reg.global <boolean>`: 正则表达式是否使用了 `g` 修饰符
- `reg.ignoreCase <boolean>`: 正则表达式是否使用了 `i` 修饰符
- `reg.multiline <boolean>`: 正则表达式是否使用了 `m` 修饰符
- `reg.unicode <boolean>`: 正则表达式是否使用了 `u` 修饰符
- `reg.sticky <boolean>`: 正则表达式是否使用了 `y` 修饰符

## 方法

### `reg.test(str)`

- 参数
  - `str <string>`: 需要检测的字符串
- 返回值
  - `<boolean>`
- 说明
  - 用于测试给定的字符串是否匹配该正则规则

### `reg.exec(str)`

- 参数
  - `str <string>`: 需要执行搜索的字符串
- 返回值
  - `null`: 未能搜索到匹配正则的字符串
  - `<array>`: 匹配结果，以数组形式返回
    - `[0]`: 第一个匹配的字符串
    - `[1], ...[n]`: 对应捕获括号中的内容
    - `index`: 匹配到的字符串中第一位字符在原字符串中的索引
    - `input`: 原始字符串
- 说明
  - 对给定的字符串执行一次搜索匹配，返回匹配的结果
  - 如果 `reg` 不含 `g` 修饰符，则相当于 `str.search(reg)` 方法
  - 如果 `reg` 含有 `g` 修饰符，则会记录本次匹配的索引，下一次匹配时将会从该索引开始匹配

### `reg.toString()`

- 返回值
  - `<string>`
- 说明
  - 将给正则表达式转换成字符串并返回

## 语法

### 字符集合

- `[xyz]`: 匹配方括号中的任意字符，包括转义字符；使用 `-` 可以指定一个范围，如 `[0-9A-Za-z]` 表示匹配任意的数字或字母
- `[^xyz]`: 匹配任何不含方括号中的字符；规则同 `[xyz]`

### 量词

- `{n}`: 匹配前一个模式刚好出现 n 次，这里 n 是一个正整数
- `{n,}`: 匹配前一个模式至少出现 n 次，这里 n 是一个正整数
- `{n,m}`: 匹配前一个模式至少出现 n 次，至多 m 次，这里 n 和 m 都是正整数
- `*`: 匹配前一个模式出现 0 或 多次，等价于 `{0,}`
- `+`: 匹配前一个模式出现 1 或 多次，等价于 `{1,}`
- `?`: 匹配前一个模式出现 0 或 1 次，等价于 `{0, 1}`；若紧邻 `*`、`+`、`?`、`{}` 量词之后，则使匹配变成非贪婪的，即匹配次数最小化
- 例子

  ```js
  let str = "abcdcba";
  let reg1 = /a.+c/; //默认为贪婪的匹配，会匹配最大的符合结果的字符串
  let reg2 = /a.+?c/; //非贪婪的匹配，匹配到符合结果的字符串时则停止匹配
  console.log(str.match(reg1)); //[ 'abcdc', index: 0, input: 'abcdcba' ]
  console.log(str.match(reg2)); //[ 'abc', index: 0, input: 'abcdcba' ]
  ```

### 条件匹配

- `x(?=y)`: 正向肯定查找，匹配模式 x 仅当模式 x 后面相邻着模式 y
- `x(?!y)`: 正向否定查找，匹配模式 x 仅当模式 x 后面不相邻模式 y
- `(?<=y)x`: 逆向肯定查找，匹配模式 x 仅当模式 x 前面相邻着模式 y
- `(?<!y)x`: 逆向否定查找，匹配模式 x 仅当模式 x 前面不相邻模式 y
- `x|y`: 匹配模式 x 或模式 y

### 边界匹配

- `^`: 匹配字符串的开始；如果设置了多行标志( `m` )，则同时匹配换行符后最近的位置
- `$`: 匹配字符串的结束；如果设置了多行标志( `m` )，则同时匹配换行符前最近的位置
- `\b`: 匹配一个零宽单词边界；如，`\blead` 表示匹配以 lead 开头的单词，`tail\b`表示匹配以 tail 结尾的单词
- `\B`: 匹配一个零宽非单词边界，匹配一个前后字符都是相同类型的位置: 都是单词或者都不是单词。
- 例子

  ```js
  let str = "lazy neko666233";
  let reg = /^lazy \bne.*233$/;
  console.log(str.match(reg)); //[ 'lazy neko666233', index: 0, input: 'lazy neko666233' ]
  ```

### 分组

- `(?:x)`: 非捕获括号，定义一个子匹配模式 x
- `(x)`: 捕获括号，定义一个子匹配模式 x 并记住该匹配项；相比于非捕获括号有额外的性能开支
- `\n`: 指向正则表达式中第 n 个捕获括号所匹配的**值**；这里 n 是一个正整数，顺序为从左向右
- 例子

  ```js
  let str1 = "2018-12-12";
  let str2 = "2018-12-13";
  let reg = /(?:[0-9]{4})-([0-9]{2})-\1/; //第一个为非捕获括号，所以 \1 指向 ([0-9]{2}) 匹配的值，即 12
  console.log(str1.match(reg)); //[ '2018-12-12', '12', index: 0, input: '2018-12-12' ]
  console.log(str2.match(reg)); //null
  ```

### 元字符

- `.`: 匹配任何单个字符，不包括行结束符(如: `\n`, `\r`, `\u2028`, `\u2029`)；在字符集合中失去特殊含义为普通字符 `.`
- `\`: 转义符号，将下一个特殊字符解释为普通字符，或将下一个普通字符解释为特殊
- `\d`: 匹配任意数字，等价于 `[0-9]`
- `\D`: 匹配任意非数字，等价于 `[^0-9]`
- `\w`: 匹配任意单词字符，等价于 `[0-9A-z_]`
- `\W`: 匹配任意非字母、数字、下划线，等价于 `[^0-9A-Za-z_]`
- `\s`: 匹配空白符，包括空格、制表符、换行符、换页符、其他 Unicode 空格
- `\S`: 匹配非空白符
- `\n`: 匹配换行符
- `\r`: 匹配回车符
- `\f`: 匹配换页符
- `\t`: 匹配水平制表符
- `\v`: 匹配垂直制表符
- `\0`: 匹配空字符
- `[\b]`: 匹配退格字符
- `\cX`: 匹配字符串中的一个控制字符，这里 X 取值为 A - Z 的字符
- `\xhh`: 匹配十六进制字符，这里 hh 为字符编码
- `\uhhhh`: 匹配 Unicode 字符，这里 hhhh 为字符编码

## 示例

- 匹配中文: `/[\u4e00-\u9fa5]/`
- 匹配邮箱: `/\w+@[0-9a-z]+\.[a-z]{2,4}/`
- 检测首尾空格: `/^\s*|\s*$/`
