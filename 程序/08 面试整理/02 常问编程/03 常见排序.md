# 常见排序

## 选择排序

算法步骤

1. 在一次排序中找到最小(大)元素，与本次排序元素首位对调
2. 从剩余元素中找到最小(大)元素，与本次排序元素首位对调
3. 重复执行上步操作直到排序完成

算法特性

- 平均时间复杂度: O(n^2^)
- 最小时间复杂度: O(n^2^)
- 最大时间复杂度: O(n^2^)
- 空间复杂度: O(1)
- 算法稳定性: 不稳定

基本实现

```js
function selectSort(arr) {
  for (let i = 0; i < arr.length; i++) {
    let min = i;
    for (j = i; j < arr.length; j++) {
      if (arr[j] < arr[min]) min = i;
    }
    [arr[i], arr[min]] = [arr[min], arr[i]];
  }
  return arr;
}
```

增加排序顺序

```js
const exchange = (arr, a, b) => {
  const temp = arr[a];
  arr[a] = arr[b];
  arr[b] = temp;
};

const selection = (arr, order = "asc") => {
  for (let i = 0; i < arr.length; i++) {
    let index = i;
    for (let j = i + 1; j < arr.length; j++) {
      if (
        (order === "asc" && arr[j] < arr[index]) ||
        (order === "desc" && arr[j] > arr[index])
      ) {
        index = j;
      }
    }
    exchange(arr, i, index);
  }
  return arr;
};
```

## 插入排序

算法步骤

1. 取出第一个元素，作为排序序列，剩余元素作为未排序序列
2. 取出未排序序列第一个元素，如果小于前一个元素，则前一个元素后移一位
3. 重复执行上一步直到前一个元素小于取出的元素，将该元素插入
4. 重复二三两步直到排序完成

基本实现

```js
const insertion = arr => {
  for (let i = 1; i < arr.length; i++) {
    let prevIdx = i - 1;
    let current = arr[i];

    while (prevIdx >= 0 && arr[prevIdx] > current) {
      arr[prevIdx + 1] = arr[prevIdx];
      prevIdx--;
    }
    arr[prevIdx + 1] = current;
  }
  return arr;
};

// 思路二
function insertSort(arr) {
  const sort = [arr[0]];
  for (let i = i; i < arr.length; i++) {
    const next = arr[i];
    let idx = 0;
    for (let j = 0; j < sort.length; j++) {
      if (sort[j] < next) idx = j + 1;
    }
    sort.splice(idx, 0, next);
  }
  return sort;
}
```

优化算法 - 折半插入

```js
const binaryInsertion = arr => {
  for (let i = 1; i < arr.length; i++) {
    let current = arr[i];
    let minIdx = 0;
    let maxIdx = i - 1;

    while (minIdx <= maxIdx) {
      let midIdx = parseInt(minIdx + maxIdx) / 2;
      if (current > arr[minIdx]) minIdx++;
      if (current < arr[maxIdx]) maxIdx--;
    }

    for (let j = i; j > minIdx; j--) {
      arr[j] = arr[j - 1];
    }

    arr[minIdx] = current;
  }
  return arr;
};
```

## 冒泡排序

```js
// 冒泡
const bubbleSort = arr => {
  for (let i = 0; i < arr.length - 1; i++) {
    for (let j = 0; j < arr.length - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
    }
  }
  return arr;
};
```

## 快速排序

```js
// 快排
const quickSort = arr => {
  if (arr.length <= 1) return arr;
  const symbol = arr[0];
  const maxArr = [];
  const minArr = [];
  const equals = [];

  arr.forEach(ele => {
    if (ele > symbol) maxArr.push(ele);
    if (ele < symbol) minArr.push(ele);
    if (ele === symbol) equals.push(ele);
  });
  return [...quickSort(minArr), ...equals, ...quickSort(maxArr)];
};
```
