[toc]

# 数据处理

## 对象拷贝

```js
// 拷贝
const clone = obj => {
  if (typeof obj !== "object" || obj === null) return obj;
  let ret;
  if (Array.isArray(obj)) {
    ret = [];
    for (let val of obj) {
      ret.push(clone(val));
    }
  } else {
    ret = {};
    for (let key in obj) {
      ret[key] = clone(obj[key]);
    }
  }
  return ret;
};

// const obj1 = {
//     a: {
//         b: {
//             c: ["d"]
//         }
//     }
// };

// console.log(copy(obj1));
```

```js
// 对象拷贝，处理 循环引用 问题
const clone = parent => {
  // 维护两个储存循环引用的数组
  const parents = [];
  const children = [];

  const _clone = parent => {
    if (parent === null) return null;
    if (typeof parent !== "object") return parent;

    let child, proto;

    if (isType(parent, "Array")) {
      // 对数组做特殊处理
      child = [];
    } else if (isType(parent, "RegExp")) {
      // 对正则对象做特殊处理
      child = new RegExp(parent.source, getRegExp(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (isType(parent, "Date")) {
      // 对Date对象做特殊处理
      child = new Date(parent.getTime());
    } else {
      // 处理对象原型
      proto = Object.getPrototypeOf(parent);
      // 利用Object.create切断原型链
      child = Object.create(proto);
    }

    // 处理循环引用
    const index = parents.indexOf(parent);

    if (index != -1) {
      // 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象
      return children[index];
    }
    parents.push(parent);
    children.push(child);

    for (let i in parent) {
      // 递归
      child[i] = _clone(parent[i]);
    }

    return child;
  };
  return _clone(parent);
};
```

## 数组扁平

```js
// flat-原生
function flatten(array) {
  return array.flat(Infinity);
}

// flat-递归
function flatten(array) {
  return array.reduce(
    (acc, cur) => acc.concat(Array.isArray(cur) ? flatten(cur) : cur),
    []
  );
}

// flat-迭代
function flatten(array) {
  const result = [];
  const stack = [...array];
  do {
    const head = stack.shift();
    if (Array.isArray(head)) {
      stack.unshift(...head);
    } else {
      result.push(head);
    }
  } while (stack.length);
  return result;
}
```

## 数组去重

```js
// unique-集合
function unique(array) {
  return [...new Set([...array])];
}

// unique-手写
function unique(array) {
  const result = [];
  let index = 0;
  do {
    if (!result.includes(array[index])) {
      result.push(array[index]);
    }
  } while (++index < array.length);
  return result;
}
```

## 类数组转数组

```js
function formatArray(arrlike) {
  return [...arrlike];
  return Array.from(arrlike);
  return Array.prototype.slice.call(arrlike);
}
```

## 数组转树

```js
var menu_list = [
  {
    id: "1-1",
    menu_name: "权限设置",
    menu_url: "setting.permission",
    parent_id: "1",
  },
  {
    id: "1-1-1",
    menu_name: "用户管理列表",
    menu_url: "setting.permission.user_list",
    parent_id: "1-1",
  },
  {
    id: "1-1-2",
    menu_name: "用户管理新增",
    menu_url: "setting.permission.user_add",
    parent_id: "1-1",
  },
  {
    id: "1-1-3",
    menu_name: "角色管理列表",
    menu_url: "setting.permission.role_list",
    parent_id: "1-1",
  },
  {
    id: "1-2",
    menu_name: "菜单设置",
    menu_url: "setting.menu",
    parent_id: "1",
  },
  {
    id: "1-2-1",
    menu_name: "菜单列表",
    menu_url: "setting.menu.menu_list",
    parent_id: "1-2",
  },
  {
    id: "1-2-2",
    menu_name: "菜单添加",
    menu_url: "setting.menu.menu_add",
    parent_id: "1-2",
  },
  {
    id: "2",
    menu_name: "订单",
    menu_url: "order",
    parent_id: 0,
  },
  {
    id: "2-1",
    menu_name: "报单审核",
    menu_url: "order.orderreview",
    parent_id: "2",
  },
  {
    id: "2-2",
    menu_name: "退款管理",
    menu_url: "order.refundmanagement",
    parent_id: "2",
  },
  {
    id: "1",
    menu_name: "设置",
    menu_url: "setting",
    parent_id: 0,
  },
];

function buildTree(list) {
  let temp = {};
  let tree = {};
  for (let i in list) {
    temp[list[i].id] = list[i];
  }
  for (let i in temp) {
    const item = temp[i];
    if (item.parent_id) {
      // 存在父节点
      // 找到父节点添加
      const parent = temp[item.parent_id];
      if (!parent.children) {
        parent.children = {};
      }
      parent.children[item.id] = item;
    } else {
      // 没有父节点
      tree[item.id] = item;
    }
  }
  return { temp, tree };
}
```
