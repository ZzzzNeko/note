# 基础原理

ES 基础函数模拟 polyfill

## 原型

```js
// 继承
function Parent() {
  this.first = "Parent";
}
Parent.prototype.getFirst = function () {
  return this.first;
};
function Child(second) {
  Parent.call(this); //执行父类的构造函数并将 `this` 指向子类实例
  // 子类属性
  this.second = second;
}
/*
  如果父类没有实例属性可以省略为下面写法；也可以直接使用，因为实例上的方法/属性优先于原型链调用
  Son.prototype = new Parent()
*/
(function () {
  var Temp = function () {};
  Temp.prototype = Parent.prototype;
  Child.prototype = new Temp();
})();
Child.prototype.constructor = Child;
// 子类原型方法
Child.prototype.getFull = function () {
  return this.first + " " + this.second;
};
```

```js
// 模拟 new
function mokeNew(klass, ...args) {
  const obj = Object.create({});
  obj.__proto__ = klass.prototype;
  const ret = klass.apply(obj, args);
  return typeof ret === "object" ? ret : obj;
}
```

```js
// 模拟 instanceof
function mockInstanceof(left, right) {
  // 获得类型的原型
  let prototype = right.prototype;
  // 获得对象的原型
  left = left.__proto__;
  // 判断对象的类型是否等于类型的原型
  while (true) {
    if (left === null) return false;
    if (prototype === left) return true;
    left = left.__proto__;
  }
}
```

## this 指向

```js
// 模拟 bind
Function.prototype.mockBind = function (oThis) {
  var aArgs = Array.prototype.slice.call(arguments, 1),
    fToBind = this,
    fNOP = function () {},
    fBound = function () {
      // this instanceof fBound === true时,说明返回的fBound被当做new的构造函数调用
      return fToBind.apply(
        this instanceof fBound ? this : oThis,
        // 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的
        aArgs.concat(Array.prototype.slice.call(arguments))
      );
    };

  // 维护原型关系
  if (this.prototype) {
    // Function.prototype doesn't have a prototype property
    fNOP.prototype = this.prototype;
  }
  // 下行的代码使fBound.prototype是fNOP的实例,因此
  // 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的实例
  fBound.prototype = new fNOP();

  return fBound;
};

Function.prototype.mockBind = function (context, ...args) {
  context._fn = this;
  return function F() {
    if (this instanceof F) {
      const result = new context._fn(...args, ...arguments);
      delete context._fn;
      return result;
    } else {
      const result = context._fn(...args, ...arguments);
      delete context._fn;
      return result;
    }
  };
};

// 模拟call
Function.prototype.mockCall = function (context, ...args) {
  context._fn = this;
  const result = context._fn(...args);
  delete context._fn;
  return result;
};

// 模拟apply
Function.prototype.mockApply = function (context, args) {
  context._fn = this;
  const result = args ? context._fn(...args) : context._fn();
  delete context._fn;
  return result;
};
```
