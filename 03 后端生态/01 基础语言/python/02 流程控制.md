# 流程控制

## 空操作

什么都不操作，用于补充语法逻辑，或作为占位符方便开发

```py
pass
```

## 赋值语句

```py
a, b, c = 'a', 'b', 'c'
```

## 条件语句

```py
x = int(input('请输入一个数: '))
if x < 0:
  print('负数')
elif x == 0:
  print('Zero')
else:
  print('正数')
```

## 分支语句(v3.10+) (TODO: 示例待补充)

与 `switch ... case ...` 类似，但增加了匹配模式使得通用性大幅提升

```py
status = int(input('http status: '))
match status:
  case 401 | 403 | 404:
    print('网络资源不存在')
  case 500:
    print('服务器不在状态')
  case _:
    print('未能匹配到状态')
```

```py
def whereIs(point):
  match point:
    case (0, 0):
      print('原点')
    case (x, 0):
      print('x 轴上')
    case (0, y):
      print('y 轴上')
    case _:
      print('非轴上')

whereIs((0, 0))
```

## 循环语句

### for 迭代器

py 中的 `for` 语句类似与 js 中的 `for item of list`, 用于迭代 列表或字符串中的元素 或可迭代对象 (TODO: 这里后面再整理，与 js 迭代器类似, py 可以自己定义 `__iter__()` 方法实现迭代器)

```py
list = [1, 2, 3, 4, 5]
for item in list:
  print(item ** 2)
```

可以借助 `range()` 辅助实现 `for(i=0; i<n; i++)` 的效果 <br/>
`range()` 与列表不同，并未真实生成列表数据，以节省空间

```py
for i in range(5)
  print(i)

# range 也可指定起止位置
range(5, 10) # 5, 6, 7, 8, 9
# range 也可指定步长，支持附属
range(0, 10, 2)
```

### `while` 循环

```py
i = 0
s = 0
while i < 10:
  s += i
  i += 1
else:
  print("sum[0-9]=" + str(s))
```

### `break` `continue`

- `break` 用于跳出最近的循环体
- `continue` 用于结束当前循环，进入下一个循环

### `else` 子句

- 属于循环的一部分，在循环结束后执行
- 若循环通关 `break` 结束，则不触发 `else`

## 异常

```py
import traceback

try:
  try:
    i = int(input('输入数字: '))
    print(1/i)
  except ZeroDivisionError:
    raise ValueError(0)
  except (ValueError) as err:
    raise Exception('运行失败') from None
  else:
    print('一切正常')
except Exception as inputError:
  traceback.print_exception(inputError)
  print(type(inputError), inputError.args, inputError)
finally:
  print('一切都结束了')
```

- `try`: 用于捕获异常
- `raise`: 可以主动抛出异常
  - 传递异常示例：如 `raise ValueError(0)`
  - 传递异常类: 如 `raise ZeroDivisionError`
  - 传递自定义异常: 如 `raise Exception('我的', '异常')`，自定义异常都从 `Exception` 类派生
  - 单独使用不携带具体异常，表示只抛出异常，可用于通用处理(如统计异常次数等)
  - 后面可以跟 `from` 子句，用与描述异常链，`except` 或 `finally` 中引起异常时自动生成
  - 后面可以跟 `from None` 禁用默认生成的异常链
- `except`: 用于匹配异常
  - 后跟指定错误类型，用于精确匹配
  - 后跟元组错误类型，可以匹配多种异常类型
  - 若为主动抛出的异常，可以使用 `as` 获取具体异常
- `else`: 用于处理未发生异常的状态
- `finally`: 为一定会执行的内容
  - 若 `except` 未能捕获到具体异常，`finally` 将先执行之后再向上抛出异常
  - 若 `except`、`else` 中触发异常，`finally` 将先执行之后再向上抛出异常
  - 若 `finally` 中包含 `break`、`continue`、`return` 语句，则不会向上抛出异常
  - 若 `try` 中包含 `break`、`continue`、`return` 语句，则 `finally` 会在此之前执行
  - 若 `finally` 中包含 `return` 语句，则返回值来自 `finally` 而非 `try`

## `with`

`with` 语句用于包装带有使用上下文管理器定义的方法的代码块的执行

执行过程

1. 使用表达式获取 上下文管理器
2. 载入上下文管理器的 `__enter__()` 方法
3. 载入上下文管理器的 `__exit__()` 方法
4. 调用 `__enter__()` 方法
   - 若 `with` 中包含一个目标，则将 `__enter__()` 执行的返回值赋予之
   - 若期间发生异常，则调用 `__exit__()`, 并传递 `类型, 值, 回溯信息` 作为参数
     - 处理返回值为 `False`: 继续排除异常
     - 处理返回值为 `True`: 继续执行后续的语句
5. 执行语句体
6. 执行 `__exit__()`，并传递 `None, None, None` 作为参数

## 函数

```py
# 函数的基本格式
def fnName(varName, defaultVar = '默认值'):
  """文档字符串
  用于描述函数的用途，方便文档的生成
  其内容可以通过 .__doc__ 属性获取
  """
  print(varName)
  return varName

print(fnName.__doc__)
```

函数的默认返回值为 `None`

```py
# 函数外部变量只能引用不能赋值(会被当做新变量处理)
# NOTE: js 中函数内部是可以修改外部变量的
a = 'a'
def changeA():
  a = 'aa'

changeA()
print(a)
```

```py
# NOTE: 函数默认值为引用对象时，多次计算时使用同一个对象
# NOTE: 但 js 中默认值为 [], {} 时会创建新的对象，而 py 中是共享的
# 可以使用 k=v 格式进行传参，可以忽略传参顺序
def callList(name="list", list=[]):
  list.append(name)
  return list

print(callList("233"))    # ['233']
print(callList("666"))    # ['233', '666']
print(callList(list=[]))  # ['list']
```

```py
# 特殊形参
# 当形参前有一个星号标注时(如 `*args`)表示除了已有形参之外的形参元祖
# 当形参前有两个星号标注时(如 `**kvs`)将接受字典类型作为其值
def showParams(fix, *args, **kvs):
  print("固定参数: ", fix)
  print("其他参数: ", args) # 类似于 js 中的 fn(a, ...args)
  print("字典参数: ", kvs)

showParams("fixed", "a", "b", "c", a=1, b=2, c=3)
```

```py
# 函数注解，给函数添加元数据的类型说明
def add(a: float, b: float) -> float:
  return a + b

# 函数注解可以通关 .__annotations__ 属性查看
print(add.__annotations__)
```

```py
# lambda 表达式，用于创建更简便的匿名函数
def add():
  return lambda a, b: a+b

print(add()(1, 2))
```

TODO: 仅位置参数
