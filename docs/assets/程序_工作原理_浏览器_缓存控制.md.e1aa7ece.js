import{_ as e,o,c,V as d}from"./chunks/framework.9dc355db.js";const x=JSON.parse('{"title":"缓存控制","description":"","frontmatter":{},"headers":[],"relativePath":"程序/工作原理/浏览器/缓存控制.md","filePath":"程序/工作原理/浏览器/缓存控制.md","lastUpdated":1687109729000}'),i={name:"程序/工作原理/浏览器/缓存控制.md"},l=d('<h1 id="缓存控制" tabindex="-1">缓存控制 <a class="header-anchor" href="#缓存控制" aria-label="Permalink to &quot;缓存控制&quot;">​</a></h1><p>在实际应用中存在大量重复的资源获取，在获取资源时会优先进行强缓存匹配，若命中失败，则发送 HTTP 请求由服务端判断是否命中协商缓存；借助合理的缓存控制可以大幅提高资源获取效率。</p><h2 id="缓存位置" tabindex="-1">缓存位置 <a class="header-anchor" href="#缓存位置" aria-label="Permalink to &quot;缓存位置&quot;">​</a></h2><p>客户端查询缓存时依据以下缓存位置的优先级进行</p><ol><li>Service Worker：用于 PWA，缓存可自由控制且持续</li><li>Memory Cache：效率高，容量小，时效短(进程关闭时释放)，常见于页面刷新和预加载(preloader)</li><li>Disk Cache：效率低，容量大，时效长，客户端最常见的缓存方式</li><li>Push Cache：HTTP2，只在会话中存在，且缓存只能被使用依次</li></ol><h2 id="缓存策略" tabindex="-1">缓存策略 <a class="header-anchor" href="#缓存策略" aria-label="Permalink to &quot;缓存策略&quot;">​</a></h2><p>通常客户端的缓存策略分为两种</p><ul><li>强缓存：不会发送请求，直接从 Memory Cache 和 Disk Cache 中获取</li><li>协商缓存：强缓存未命中时发起请求，由服务端判断是否命中缓存</li></ul><p>强缓存根据 <code>Cache-Control</code> 或 <code>Expires</code> 字段判断是否命中，命中时返回 <code>200</code> 和 <code>from memory/disk cache</code></p><ul><li><code>Expires: [具体时间]</code>: HTTP1.0，存在服务端与客户端时间不一的问题</li><li><code>Cache-Control: [指令]</code>: HTTP1.1，优先级高于 <code>Expires</code>，多个指令使用逗号分隔 <ul><li><code>max-age=xxx</code>: 单位秒，表示最大缓存时间</li><li><code>s-maxage=xxx</code>: 覆盖 <code>max-age</code>，只在代理服务器中生效</li><li><code>no-store</code>: 不缓存</li><li><code>no-cache</code>: 资源被缓存但立即失效，下次请求时走协商缓存</li><li><code>public</code>: 表示响应可被客户端和代理服务器缓存</li><li><code>private</code>: 表示响应只可被客户端缓存</li><li><code>max-stale=xxx</code>: 可容忍最大过期时间，指定时间内即使过期也使用当前缓存</li><li><code>min-fresh=xxx</code>: 可容忍最小新鲜度，指定时间内希望获取最新响应</li></ul></li></ul><p>协商缓存根据 <code>Last-Modified</code> 或 <code>Etag</code> 字段判断是否使用缓存，命中时返回 <code>304</code> 和 <code>Not Modified</code></p><ul><li><code>Last-Modified: [具体时间]</code>: HTTP1.1，根据资源修改时间判断是否使用缓存(存在精度、负载均衡服务器中时间不一致问题) <ul><li>客户端首次请求时，服务端在响应头添加 <code>Last-Modified</code> 字段</li><li>客户端再次请求时，客户端在请求头添加 <code>If-Modified-Since</code> 字段(值同上次返回的 <code>Last-Modified</code>)</li><li>服务端接收请求后，根据 <code>If-Modified-Since</code> 与对应资源最后修改时间进行对比判断是否使用缓存</li></ul></li><li><code>ETag: [资源标识]</code>: HTTP1.1，优先级更高，根据资源内容生成的唯一标识判断是否使用缓存(会有额外开销) <ul><li>服务端根据资源内容生成对应的唯一标识</li><li>客户端首次请求时，服务端在响应头添加 <code>ETag</code> 字段</li><li>客户端再次请求时，客户端在请求头添加 <code>If-None-Match</code> 字段(值同上次返回的 <code>ETag</code>)</li><li>服务端接收请求后，根据 <code>If-None-Match</code> 与对应资源的 <code>ETag</code> 进行比对判断是否使用缓存</li></ul></li></ul>',12),a=[l];function t(r,s,n,h,_,p){return o(),c("div",null,a)}const f=e(i,[["render",t]]);export{x as __pageData,f as default};
