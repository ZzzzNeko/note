import{_ as l,v as i,b as a,R as e}from"./chunks/framework.f165b36f.js";const c=JSON.parse('{"title":"HTTP","description":"","frontmatter":{},"headers":[],"relativePath":"程序/网络通信/网络模型/应用层 - HTTP.md","filePath":"程序/网络通信/网络模型/应用层 - HTTP.md","lastUpdated":1688489323000}'),t={name:"程序/网络通信/网络模型/应用层 - HTTP.md"},r=e('<h1 id="http" tabindex="-1">HTTP <a class="header-anchor" href="#http" aria-label="Permalink to &quot;HTTP&quot;">​</a></h1><h2 id="http-的特点" tabindex="-1">HTTP 的特点 <a class="header-anchor" href="#http-的特点" aria-label="Permalink to &quot;HTTP 的特点&quot;">​</a></h2><ul><li>灵活</li><li>请求-响应</li><li>传输可靠</li><li>无状态</li></ul><h2 id="http-的发展" tabindex="-1">HTTP 的发展 <a class="header-anchor" href="#http-的发展" aria-label="Permalink to &quot;HTTP 的发展&quot;">​</a></h2><p>HTTP 最初的版本为 0.9，仅定义了建立 TCP 连接后，客户端向服务端请求的资源，进行支持 GET 方法； <br> HTTP 1.0 版本初步定义了传输规则：增加了 POST、HEAD 方法，增加了 Header 头，定义了状态码且支持任意格式数据 <br> HTTP 1.1 版本除了完善传输规则并增加了 持久连接、管道机制、缓存控制、断点续传、虚拟网络 等特性 <br> 目前 1.1 版本也是主要使用的版本，由于 HTTP 的数据为明文传输，存在安全隐患，因而发展出了 HTTPS 协议，通过证书确保通信双方可信，传输时对数据加密避免被第三方接持 <br> HTTP 2 优化了通信效率，对数据头部进行压缩，实现了多路复用减少请求连接</p><h2 id="http-1-x" tabindex="-1">HTTP 1.x <a class="header-anchor" href="#http-1-x" aria-label="Permalink to &quot;HTTP 1.x&quot;">​</a></h2><h3 id="报文格式" tabindex="-1">报文格式 <a class="header-anchor" href="#报文格式" aria-label="Permalink to &quot;报文格式&quot;">​</a></h3><ul><li>请求报文：请求行(方法 地址 协议) - 通用信息头 - 请求头 - 实体头(空行) - 报文主体</li><li>响应报文：状态行(协议 状态) - 通用信息头 - 响应头 - 实体头(空行) - 报文主体</li></ul><p>请求方法包括(其中 GET、HEAD、OPTIONS、TRACE、DELETE、PUT 是幂等请求)(幂等性指一或多次请求某资源应具有同样的副作用)</p><ul><li>GET: 请求获取指定资源</li><li>POST: 请求提交数据进行处理</li><li>PUT: 请求提交数据进行替换 (整体替换)</li><li>PATCH: 请求提交数据进行替换 (部分替换) (与 PUT 类似，但由于是部分替换，因而不被认为是幂等的)</li><li>DELETE: 请求删除指定资源</li><li>OPTIONS: 用于获取服务端支持的请求方法</li><li>HEAD: 请求获取资源的响应消息头</li><li>TRACE: 请求服务器回送收到的请求信息，主要用于测试或诊断</li><li>CONNECT: 建立连接隧道，用于代理服务器</li></ul><p>状态码由三位数字组成，其首位代表状态类别</p><ul><li>1xx：消息类状态，如：100-客户端应该继续发送请求，102-处理将被继续执行</li><li>2xx：成功类状态，如：200-成功</li><li>3xx：重定向状态，如：301-永久重定向，302-临时重定向，304-命中协商缓存，305-指定访问代理</li><li>4xx：客户端错误，如：400-请求语法错误，401-用户未认证，403-请求被拒绝，404-资源不存在，405-请求方法错误</li><li>5xx：服务端错误，如：500-服务器异常，502-网关错误，503-服务器维护或过载，504-网关超时，505-HTTP 版本不支持</li></ul><h3 id="传输特性" tabindex="-1">传输特性 <a class="header-anchor" href="#传输特性" aria-label="Permalink to &quot;传输特性&quot;">​</a></h3><ul><li>持久连接：TCP 连接不关闭，可以被多个请求复用 <ul><li>默认状态下所有连接都是持久连接</li><li>可通过 <code>Connection: Keep-Alive</code> 或 <code>Connection: close</code> 指定开启或关闭</li></ul></li><li>管道机制：在一个 TCP 连接中，可以同时发送多个请求，发送过程中不需先等待服务端响应 <ul><li>依赖于持久连接</li><li>由于未收到响应就可以继续发生请求，所以只支持幂等请求</li><li>需要服务端也支持管道化，还可能导致对头阻塞问题，浏览器默认关闭管道化</li></ul></li><li>断点续传：通过设置请求头中的 Range 字段进行实现</li><li>虚拟网络：同一服务器上支持多个共享同一 IP 的虚拟主机</li><li>缓存控制：优化了缓存标识的判断规则</li></ul><h3 id="存在问题" tabindex="-1">存在问题 <a class="header-anchor" href="#存在问题" aria-label="Permalink to &quot;存在问题&quot;">​</a></h3><ul><li>明文传输：无法确保传输的安全性</li><li>性能浪费：持久链接会占用服务端带来更大的服务器压力</li><li>队头阻塞：请求管道化带来的新问题，多个有序请求可能因对头受阻导致整列数据受阻。 <ul><li>独立的消息数据在一个链路上传输</li><li>队列上传输的数据又严格的顺序约束</li><li>当一列的第一个数据包(队头)受阻而导致整列数据包受阻</li></ul></li></ul><p>队头阻塞的处理</p><ul><li>HTTP 1.x 默认关闭管道化</li><li>HTTP 1.x 使用并发连接(Chrome 默认 6 个)和域名分片(根据二级域名划分业务提高最大并发)提高请求效率</li><li>HTTP 2 中引入 二进制分针和多路复用 处理</li></ul><h2 id="https" tabindex="-1">HTTPS <a class="header-anchor" href="#https" aria-label="Permalink to &quot;HTTPS&quot;">​</a></h2><p>HTTPS = HTTP + SSL/TLS，即对传输信息进行了加密<br> 附：SSL-安全套接层，TLS-传输层安全(1.2 以上安全)，主流的版本配置为 TLS1.2 + SSL3.3<br></p><p>HTTP 为明文传递，存在以下问题</p><ul><li>窃听风险：第三方可以获取通信内容</li><li>篡改风险：第三方可以修改通信内容</li><li>冒充风险：第三方可以冒充参与通信</li></ul><p>SSL/TLS 协议进行了以下处理</p><ul><li>信息加密，确保第三方无法窃听</li><li>信息校验，确保识别被篡改信息</li><li>配备证书，防止第三方身份冒充</li></ul><h3 id="加密方式" tabindex="-1">加密方式 <a class="header-anchor" href="#加密方式" aria-label="Permalink to &quot;加密方式&quot;">​</a></h3><p>对称加密：加密解密使用同一个密钥</p><ul><li>优点：加密解密效率高</li><li>缺点：密钥可以被窃取</li></ul><p>非对称加密：客户端使用公钥加密，服务端使用私钥解密</p><ul><li>优点：私钥无法被窃取</li><li>缺点：加密解密效率低</li></ul><h3 id="工作流程" tabindex="-1">工作流程 <a class="header-anchor" href="#工作流程" aria-label="Permalink to &quot;工作流程&quot;">​</a></h3><p>公钥加密：客户端先向服务端索要公钥，然后用公钥加密信息，服务端收到密文后使用私钥解密</p><ul><li>公钥存放在证书中，只要证书可信，公钥则可信</li><li>对称加密，减少加密运算消耗时间</li></ul><p>协议过程(步骤 1 和 2 为握手阶段)</p><ol><li>客户端向服务端索要并验证公钥</li><li>客户端与服务端协商生成对话密钥</li><li>客户端与服务端采用对话密钥加密通信</li></ol><p>握手阶段(通信为明文传输)</p><ol><li>客户端向服务端发出加密通信请求，ClientHello 请求 <ul><li>协议版本</li><li>客户端生成的随机数</li><li>支持的加密方法</li><li>支持的压缩方法</li></ul></li><li>服务端接收请求后向客户端回应，ServerHello 响应 <ul><li>确认使用的协议版本(若与客户端不一致，服务端关闭加密通信)</li><li>服务端生成的随机数</li><li>确认使用的加密方法</li><li>服务器证书</li></ul></li><li>客户端收到响应后验证证书并获取公钥，随后向服务器发送请求 <ul><li>随机数(又称 pre-master key)，用于服务器公钥加密，防止被窃听</li><li>编码通知，决定加密方法和密钥</li><li>客户端握手结束通知，其值为之前内容的 hash 值，供服务端校验</li></ul></li><li>服务端接收到请求后，根据上述三个随机数生成会话密钥，之后发送 <ul><li>编码通知</li><li>服务端握手结束通知，值为内容 hash，共客户端校验</li></ul></li></ol><p>流程梳理</p><ol><li>客户端 -- client hello --&gt; 服务端</li><li>服务端 -- 证书(公钥) --&gt; 客户端</li><li>客户端(获取证书公钥) -- 公钥加密信息 --&gt; 服务端</li><li>服务端(私钥解密信息) -- 生成会话密钥 --&gt; 客户端</li><li>后续服务端与客户端使用会话密钥进行加密解密通信(对称加密)</li></ol><h2 id="http-2" tabindex="-1">HTTP 2 <a class="header-anchor" href="#http-2" aria-label="Permalink to &quot;HTTP 2&quot;">​</a></h2><p>HTTP 2 进一步优化了通信性能，并解决了 1.1 中队头阻塞等问题</p><ul><li>二进制分帧：引入头信息帧和数据帧</li><li>请求优先级：可以设置数据帧优先级，优化处理顺序</li><li>多路复用：用于解决队头阻塞问题</li><li>头部压缩：用于优化 Header 信息占比过重的请求 (<code>HPACK</code> 算法)</li><li>服务端推送：允许服务端主动向客户端推送</li></ul><h3 id="二进制分帧" tabindex="-1">二进制分帧 <a class="header-anchor" href="#二进制分帧" aria-label="Permalink to &quot;二进制分帧&quot;">​</a></h3><p>帧：报文被拆分为二进制帧，帧作为最小通信单位，承载特定类型的数据(Header 帧、Data 帧) <br> 消息：HTTP 消息(请求、响应)由一个或多个帧组成 <br> 流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数 ID。 <br></p><p>对于相同 Stream ID 帧是有序传输的 <br> 对于不同 Stream ID 帧是无序传输的 <br> 接收到二进制帧后将对相同 Stream ID 的帧进行组装 <br> 帧中包含着优先级、流量控制等信息，便于优化处理效率</p><h3 id="头部压缩" tabindex="-1">头部压缩 <a class="header-anchor" href="#头部压缩" aria-label="Permalink to &quot;头部压缩&quot;">​</a></h3><p>采用<a href="https://blog.csdn.net/u010129119/article/details/79392545" target="_blank" rel="noreferrer">HPACK</a>算法进行压缩，主要包括</p><ul><li>常用头信息规则映射</li><li>哈弗曼编码压缩数据</li></ul><h3 id="多路复用" tabindex="-1">多路复用 <a class="header-anchor" href="#多路复用" aria-label="Permalink to &quot;多路复用&quot;">​</a></h3><p>可以使用单一 TCP 连接发送多个请求，数据流以消息形式发送，消息由帧组成，帧首部添加了流标识，可以无序发送，由接收方组装，从而解决 1.1 中队头阻塞的问题。</p><h3 id="服务端推送" tabindex="-1">服务端推送 <a class="header-anchor" href="#服务端推送" aria-label="Permalink to &quot;服务端推送&quot;">​</a></h3><p>服务端可以在接收客户端请求后，主动推送其他资源，客户端后续发送请求时若存在相关资源则可以直接通过缓存读取</p>',51),h=[r];function o(T,u,n,d,p,s){return i(),a("div",null,h)}const b=l(t,[["render",o]]);export{c as __pageData,b as default};
