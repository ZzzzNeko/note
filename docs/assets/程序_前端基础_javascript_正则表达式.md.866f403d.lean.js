import{_ as l,v as o,b as s,R as e}from"./chunks/framework.ecc14119.js";const u=JSON.parse('{"title":"正则表达式","description":"","frontmatter":{},"headers":[],"relativePath":"程序/前端基础/javascript/正则表达式.md","filePath":"程序/前端基础/javascript/正则表达式.md","lastUpdated":1690890461000}'),a={name:"程序/前端基础/javascript/正则表达式.md"},c=e(`<h1 id="正则表达式" tabindex="-1">正则表达式 <a class="header-anchor" href="#正则表达式" aria-label="Permalink to &quot;正则表达式&quot;">​</a></h1><h2 id="创建" tabindex="-1">创建 <a class="header-anchor" href="#创建" aria-label="Permalink to &quot;创建&quot;">​</a></h2><p><code>/source/flags</code> 或 <code>new RegExp(source[, flags])</code></p><ul><li><code>source</code>: 正则表达式文本</li><li><code>flags</code>: 修饰符，多个修饰符可以任意组合，取值如下 <ul><li><code>g</code>: 全局匹配，即查找所有匹配，而不是找到第一个匹配后停止</li><li><code>i</code>: 忽略大小写</li><li><code>m</code>: 多行，将 <code>^</code> 和 <code>$</code> 规则应用在多行的每一行中</li><li><code>u</code>: Unicode</li><li><code>y</code>: 粘性匹配，仅匹配目标字符串中此正则表达式的 lastIndex 属性指示的索引(并且不尝试从任何后续的索引匹配)。</li></ul></li></ul><h2 id="属性" tabindex="-1">属性 <a class="header-anchor" href="#属性" aria-label="Permalink to &quot;属性&quot;">​</a></h2><ul><li><code>reg.source &lt;string&gt;</code>: 正则表达式文本部分，即 <code>source</code> 参数</li><li><code>reg.flags &lt;string&gt;</code>: 正则表达式修饰符部分，即 <code>flags</code> 参数</li><li><code>reg.global &lt;boolean&gt;</code>: 正则表达式是否使用了 <code>g</code> 修饰符</li><li><code>reg.ignoreCase &lt;boolean&gt;</code>: 正则表达式是否使用了 <code>i</code> 修饰符</li><li><code>reg.multiline &lt;boolean&gt;</code>: 正则表达式是否使用了 <code>m</code> 修饰符</li><li><code>reg.unicode &lt;boolean&gt;</code>: 正则表达式是否使用了 <code>u</code> 修饰符</li><li><code>reg.sticky &lt;boolean&gt;</code>: 正则表达式是否使用了 <code>y</code> 修饰符</li></ul><h2 id="方法" tabindex="-1">方法 <a class="header-anchor" href="#方法" aria-label="Permalink to &quot;方法&quot;">​</a></h2><h3 id="reg-test-str" tabindex="-1"><code>reg.test(str)</code> <a class="header-anchor" href="#reg-test-str" aria-label="Permalink to &quot;\`reg.test(str)\`&quot;">​</a></h3><ul><li>参数 <ul><li><code>str &lt;string&gt;</code>: 需要检测的字符串</li></ul></li><li>返回值 <ul><li><code>&lt;boolean&gt;</code></li></ul></li><li>说明 <ul><li>用于测试给定的字符串是否匹配该正则规则</li></ul></li></ul><h3 id="reg-exec-str" tabindex="-1"><code>reg.exec(str)</code> <a class="header-anchor" href="#reg-exec-str" aria-label="Permalink to &quot;\`reg.exec(str)\`&quot;">​</a></h3><ul><li>参数 <ul><li><code>str &lt;string&gt;</code>: 需要执行搜索的字符串</li></ul></li><li>返回值 <ul><li><code>null</code>: 未能搜索到匹配正则的字符串</li><li><code>&lt;array&gt;</code>: 匹配结果，以数组形式返回 <ul><li><code>[0]</code>: 第一个匹配的字符串</li><li><code>[1], ...[n]</code>: 对应捕获括号中的内容</li><li><code>index</code>: 匹配到的字符串中第一位字符在原字符串中的索引</li><li><code>input</code>: 原始字符串</li></ul></li></ul></li><li>说明 <ul><li>对给定的字符串执行一次搜索匹配，返回匹配的结果</li><li>如果 <code>reg</code> 不含 <code>g</code> 修饰符，则相当于 <code>str.search(reg)</code> 方法</li><li>如果 <code>reg</code> 含有 <code>g</code> 修饰符，则会记录本次匹配的索引，下一次匹配时将会从该索引开始匹配</li></ul></li></ul><h3 id="reg-tostring" tabindex="-1"><code>reg.toString()</code> <a class="header-anchor" href="#reg-tostring" aria-label="Permalink to &quot;\`reg.toString()\`&quot;">​</a></h3><ul><li>返回值 <ul><li><code>&lt;string&gt;</code></li></ul></li><li>说明 <ul><li>将给正则表达式转换成字符串并返回</li></ul></li></ul><h2 id="语法" tabindex="-1">语法 <a class="header-anchor" href="#语法" aria-label="Permalink to &quot;语法&quot;">​</a></h2><h3 id="字符集合" tabindex="-1">字符集合 <a class="header-anchor" href="#字符集合" aria-label="Permalink to &quot;字符集合&quot;">​</a></h3><ul><li><code>[xyz]</code>: 匹配方括号中的任意字符，包括转义字符；使用 <code>-</code> 可以指定一个范围，如 <code>[0-9A-Za-z]</code> 表示匹配任意的数字或字母</li><li><code>[^xyz]</code>: 匹配任何不含方括号中的字符；规则同 <code>[xyz]</code></li></ul><h3 id="量词" tabindex="-1">量词 <a class="header-anchor" href="#量词" aria-label="Permalink to &quot;量词&quot;">​</a></h3><ul><li><p><code>{n}</code>: 匹配前一个模式刚好出现 n 次，这里 n 是一个正整数</p></li><li><p><code>{n,}</code>: 匹配前一个模式至少出现 n 次，这里 n 是一个正整数</p></li><li><p><code>{n,m}</code>: 匹配前一个模式至少出现 n 次，至多 m 次，这里 n 和 m 都是正整数</p></li><li><p><code>*</code>: 匹配前一个模式出现 0 或 多次，等价于 <code>{0,}</code></p></li><li><p><code>+</code>: 匹配前一个模式出现 1 或 多次，等价于 <code>{1,}</code></p></li><li><p><code>?</code>: 匹配前一个模式出现 0 或 1 次，等价于 <code>{0, 1}</code>；若紧邻 <code>*</code>、<code>+</code>、<code>?</code>、<code>{}</code> 量词之后，则使匹配变成非贪婪的，即匹配次数最小化</p></li><li><p>例子</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> str </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">abcdcba</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> reg1 </span><span style="color:#89DDFF;">=</span><span style="color:#C3E88D;"> </span><span style="color:#89DDFF;">/</span><span style="color:#C3E88D;">a.</span><span style="color:#89DDFF;">+</span><span style="color:#C3E88D;">c</span><span style="color:#89DDFF;">/</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//默认为贪婪的匹配，会匹配最大的符合结果的字符串</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> reg2 </span><span style="color:#89DDFF;">=</span><span style="color:#C3E88D;"> </span><span style="color:#89DDFF;">/</span><span style="color:#C3E88D;">a.</span><span style="color:#89DDFF;">+?</span><span style="color:#C3E88D;">c</span><span style="color:#89DDFF;">/</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//非贪婪的匹配，匹配到符合结果的字符串时则停止匹配</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(str</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">match</span><span style="color:#A6ACCD;">(reg1))</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//[ &#39;abcdc&#39;, index: 0, input: &#39;abcdcba&#39; ]</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(str</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">match</span><span style="color:#A6ACCD;">(reg2))</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//[ &#39;abc&#39;, index: 0, input: &#39;abcdcba&#39; ]</span></span></code></pre></div></li></ul><h3 id="条件匹配" tabindex="-1">条件匹配 <a class="header-anchor" href="#条件匹配" aria-label="Permalink to &quot;条件匹配&quot;">​</a></h3><ul><li><code>x(?=y)</code>: 正向肯定查找，匹配模式 x 仅当模式 x 后面相邻着模式 y</li><li><code>x(?!y)</code>: 正向否定查找，匹配模式 x 仅当模式 x 后面不相邻模式 y</li><li><code>(?&lt;=y)x</code>: 逆向肯定查找，匹配模式 x 仅当模式 x 前面相邻着模式 y</li><li><code>(?&lt;!y)x</code>: 逆向否定查找，匹配模式 x 仅当模式 x 前面不相邻模式 y</li><li><code>x|y</code>: 匹配模式 x 或模式 y</li></ul><h3 id="边界匹配" tabindex="-1">边界匹配 <a class="header-anchor" href="#边界匹配" aria-label="Permalink to &quot;边界匹配&quot;">​</a></h3><ul><li><p><code>^</code>: 匹配字符串的开始；如果设置了多行标志( <code>m</code> )，则同时匹配换行符后最近的位置</p></li><li><p><code>$</code>: 匹配字符串的结束；如果设置了多行标志( <code>m</code> )，则同时匹配换行符前最近的位置</p></li><li><p><code>\\b</code>: 匹配一个零宽单词边界；如，<code>\\blead</code> 表示匹配以 lead 开头的单词，<code>tail\\b</code>表示匹配以 tail 结尾的单词</p></li><li><p><code>\\B</code>: 匹配一个零宽非单词边界，匹配一个前后字符都是相同类型的位置: 都是单词或者都不是单词。</p></li><li><p>例子</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> str </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">lazy neko666233</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> reg </span><span style="color:#89DDFF;">=</span><span style="color:#C3E88D;"> </span><span style="color:#89DDFF;">/</span><span style="color:#89DDFF;font-style:italic;">^</span><span style="color:#C3E88D;">lazy </span><span style="color:#89DDFF;font-style:italic;">\\b</span><span style="color:#C3E88D;">ne.</span><span style="color:#89DDFF;">*</span><span style="color:#C3E88D;">233</span><span style="color:#89DDFF;font-style:italic;">$</span><span style="color:#89DDFF;">/</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(str</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">match</span><span style="color:#A6ACCD;">(reg))</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//[ &#39;lazy neko666233&#39;, index: 0, input: &#39;lazy neko666233&#39; ]</span></span></code></pre></div></li></ul><h3 id="分组" tabindex="-1">分组 <a class="header-anchor" href="#分组" aria-label="Permalink to &quot;分组&quot;">​</a></h3><ul><li><p><code>(?:x)</code>: 非捕获括号，定义一个子匹配模式 x</p></li><li><p><code>(x)</code>: 捕获括号，定义一个子匹配模式 x 并记住该匹配项；相比于非捕获括号有额外的性能开支</p></li><li><p><code>\\n</code>: 指向正则表达式中第 n 个捕获括号所匹配的<strong>值</strong>；这里 n 是一个正整数，顺序为从左向右</p></li><li><p>例子</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> str1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">2018-12-12</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> str2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">2018-12-13</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> reg </span><span style="color:#89DDFF;">=</span><span style="color:#C3E88D;"> </span><span style="color:#89DDFF;">/(?:[</span><span style="color:#C3E88D;">0-9</span><span style="color:#89DDFF;">]{4})</span><span style="color:#C3E88D;">-</span><span style="color:#89DDFF;">([</span><span style="color:#C3E88D;">0-9</span><span style="color:#89DDFF;">]{2})</span><span style="color:#C3E88D;">-</span><span style="color:#F78C6C;">\\1</span><span style="color:#89DDFF;">/</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//第一个为非捕获括号，所以 \\1 指向 ([0-9]{2}) 匹配的值，即 12</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(str1</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">match</span><span style="color:#A6ACCD;">(reg))</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//[ &#39;2018-12-12&#39;, &#39;12&#39;, index: 0, input: &#39;2018-12-12&#39; ]</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(str2</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">match</span><span style="color:#A6ACCD;">(reg))</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//null</span></span></code></pre></div></li></ul><h3 id="元字符" tabindex="-1">元字符 <a class="header-anchor" href="#元字符" aria-label="Permalink to &quot;元字符&quot;">​</a></h3><ul><li><code>.</code>: 匹配任何单个字符，不包括行结束符(如: <code>\\n</code>, <code>\\r</code>, <code>\\u2028</code>, <code>\\u2029</code>)；在字符集合中失去特殊含义为普通字符 <code>.</code></li><li><code>\\</code>: 转义符号，将下一个特殊字符解释为普通字符，或将下一个普通字符解释为特殊</li><li><code>\\d</code>: 匹配任意数字，等价于 <code>[0-9]</code></li><li><code>\\D</code>: 匹配任意非数字，等价于 <code>[^0-9]</code></li><li><code>\\w</code>: 匹配任意单词字符，等价于 <code>[0-9A-z_]</code></li><li><code>\\W</code>: 匹配任意非字母、数字、下划线，等价于 <code>[^0-9A-Za-z_]</code></li><li><code>\\s</code>: 匹配空白符，包括空格、制表符、换行符、换页符、其他 Unicode 空格</li><li><code>\\S</code>: 匹配非空白符</li><li><code>\\n</code>: 匹配换行符</li><li><code>\\r</code>: 匹配回车符</li><li><code>\\f</code>: 匹配换页符</li><li><code>\\t</code>: 匹配水平制表符</li><li><code>\\v</code>: 匹配垂直制表符</li><li><code>\\0</code>: 匹配空字符</li><li><code>[\\b]</code>: 匹配退格字符</li><li><code>\\cX</code>: 匹配字符串中的一个控制字符，这里 X 取值为 A - Z 的字符</li><li><code>\\xhh</code>: 匹配十六进制字符，这里 hh 为字符编码</li><li><code>\\uhhhh</code>: 匹配 Unicode 字符，这里 hhhh 为字符编码</li></ul><h2 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h2><ul><li>匹配中文: <code>/[\\u4e00-\\u9fa5]/</code></li><li>匹配邮箱: <code>/\\w+@[0-9a-z]+\\.[a-z]{2,4}/</code></li><li>检测首尾空格: <code>/^\\s*|\\s*$/</code></li></ul>`,28),n=[c];function t(p,i,r,d,y,D){return o(),s("div",null,n)}const h=l(a,[["render",t]]);export{u as __pageData,h as default};
