(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{287:function(v,_,t){"use strict";t.r(_);var l=t(10),a=Object(l.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"http"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[v._v("#")]),v._v(" HTTP")]),v._v(" "),_("h2",{attrs:{id:"http-的发展"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-的发展"}},[v._v("#")]),v._v(" HTTP 的发展")]),v._v(" "),_("p",[v._v("HTTP 最初的版本为 0.9，仅定义了建立 TCP 连接后，客户端向服务端请求的资源，进行支持 GET 方法； "),_("br"),v._v("\nHTTP 1.0 版本初步定义了传输规则：增加了 POST、HEAD 方法，增加了 Header 头，定义了状态码且支持任意格式数据 "),_("br"),v._v("\nHTTP 1.1 版本除了完善传输规则并增加了 持久连接、管道机制、缓存控制、断电续传、虚拟网络 等特性 "),_("br"),v._v("\n目前 1.1 版本也是主要使用的版本，由于 HTTP 的数据为明文传输，存在安全隐患，因而发展出了 HTTPS 协议，通过证书确保通信双方可信，传输时对数据加密避免被第三方接持 "),_("br"),v._v("\nHTTP 2 优化了通信效率，对数据头部进行压缩，实现了多路复用减少请求连接")]),v._v(" "),_("h2",{attrs:{id:"http-1-x"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-1-x"}},[v._v("#")]),v._v(" HTTP 1.x")]),v._v(" "),_("h3",{attrs:{id:"报文格式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#报文格式"}},[v._v("#")]),v._v(" 报文格式")]),v._v(" "),_("ul",[_("li",[v._v("请求报文：请求行(方法 地址 协议) - 通用信息头 - 请求头 - 实体头(空行) - 报文主体")]),v._v(" "),_("li",[v._v("响应报文：状态行(协议 状态) - 通用信息头 - 响应头 - 实体头(空行) - 报文主体")])]),v._v(" "),_("p",[v._v("请求方法包括")]),v._v(" "),_("ul",[_("li",[v._v("GET: 请求获取指定资源")]),v._v(" "),_("li",[v._v("POST: 请求提交数据进行处理")]),v._v(" "),_("li",[v._v("PUT: 请求提交数据进行替换")]),v._v(" "),_("li",[v._v("DELETE: 请求删除指定资源")]),v._v(" "),_("li",[v._v("OPTIONS: 用于获取服务端支持的请求方法")]),v._v(" "),_("li",[v._v("HEAD: 请求获取资源的响应消息头")]),v._v(" "),_("li",[v._v("TRACE: 请求服务器回送收到的请求信息，主要用于测试或诊断")]),v._v(" "),_("li",[v._v("CONNECT: 建立连接隧道，用于代理服务器")])]),v._v(" "),_("p",[v._v("状态码由三位数字组成，其首位代表状态类别")]),v._v(" "),_("ul",[_("li",[v._v("1xx：消息类状态，如：100-客户端应该继续发送请求，102-处理将被继续执行")]),v._v(" "),_("li",[v._v("2xx：成功类状态，如：200-成功")]),v._v(" "),_("li",[v._v("3xx：重定向状态，如：301-永久重定向，302-临时重定向，304-命中协商缓存，305-指定访问代理")]),v._v(" "),_("li",[v._v("4xx：客户端错误，如：400-请求语法错误，401-用户未认证，403-请求被拒绝，404-资源不存在，405-请求方法错误")]),v._v(" "),_("li",[v._v("5xx：服务端错误，如：500-服务器异常，502-网关错误，503-服务器维护或过载，504-网关超时，505-HTTP 版本不支持")])]),v._v(" "),_("h3",{attrs:{id:"传输特性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#传输特性"}},[v._v("#")]),v._v(" 传输特性")]),v._v(" "),_("ul",[_("li",[v._v("持久连接：TCP 连接默认不关闭，可以被多个请求复用")]),v._v(" "),_("li",[v._v("管道机制：在一个 TCP 连接中，可以同时发送多个请求")]),v._v(" "),_("li",[v._v("断点续传：通过设置请求头中的 Range 字段进行实现")]),v._v(" "),_("li",[v._v("虚拟网络：同一服务器上支持多个共享同一 IP 的虚拟主机")])]),v._v(" "),_("p",[v._v("附：")]),v._v(" "),_("ul",[_("li",[v._v("持久连接：设置 "),_("code",[v._v("Connection: Keep-Alive")]),v._v(" 或 "),_("code",[v._v("Connection: close")]),v._v(" 开启或关闭，1.1 中默认开启- 管道机制：管道化要求响应有序，只支持幂等请求，可能导致对头阻塞问题，默认关闭")])]),v._v(" "),_("h3",{attrs:{id:"存在问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#存在问题"}},[v._v("#")]),v._v(" 存在问题")]),v._v(" "),_("ul",[_("li",[v._v("明文传输：无法确保传输的安全性")]),v._v(" "),_("li",[v._v("性能浪费：持久链接会占用服务端带来更大的服务器压力")]),v._v(" "),_("li",[v._v("队头阻塞：请求管道化带来的新问题，多个有序请求可能因对头受阻导致整列数据受阻。")])]),v._v(" "),_("p",[v._v("HTTP1.x 由存在对头阻塞问题，管道化默认关闭，通常使用并发连接(Chrome 默认 6 各)和域名分片(根据二级域名划分业务提高最大并发)提高请求效率")]),v._v(" "),_("h2",{attrs:{id:"https"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[v._v("#")]),v._v(" HTTPS")]),v._v(" "),_("p",[v._v("HTTPS = HTTP + SSL/TLS，即对传输信息进行了加密"),_("br"),v._v("\n附：SSL-安全套接层，TLS-传输层安全(1.2 以上安全)，主流的版本配置为 TLS1.2 + SSL3.3"),_("br")]),v._v(" "),_("p",[v._v("HTTP 为明文传递，存在以下问题")]),v._v(" "),_("ul",[_("li",[v._v("窃听风险：第三方可以获取通信内容")]),v._v(" "),_("li",[v._v("篡改风险：第三方可以修改通信内容")]),v._v(" "),_("li",[v._v("冒充风险：第三方可以冒充参与通信")])]),v._v(" "),_("p",[v._v("SSL/TLS 协议进行了以下处理")]),v._v(" "),_("ul",[_("li",[v._v("信息加密，确保第三方无法窃听")]),v._v(" "),_("li",[v._v("信息校验，确保识别被篡改信息")]),v._v(" "),_("li",[v._v("配备证书，防止第三方身份冒充")])]),v._v(" "),_("h3",{attrs:{id:"加密方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#加密方式"}},[v._v("#")]),v._v(" 加密方式")]),v._v(" "),_("p",[v._v("对称加密：加密解密使用同一个密钥")]),v._v(" "),_("ul",[_("li",[v._v("优点：加密解密效率高")]),v._v(" "),_("li",[v._v("缺点：密钥可以被窃取")])]),v._v(" "),_("p",[v._v("非对称加密：客户端使用公钥加密，服务端使用私钥解密")]),v._v(" "),_("ul",[_("li",[v._v("优点：私钥无法被窃取")]),v._v(" "),_("li",[v._v("缺点：加密解密效率低")])]),v._v(" "),_("h3",{attrs:{id:"工作流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#工作流程"}},[v._v("#")]),v._v(" 工作流程")]),v._v(" "),_("p",[v._v("公钥加密：客户端先向服务端索要公钥，然后用公钥加密信息，服务端收到密文后使用私钥解密")]),v._v(" "),_("ul",[_("li",[v._v("公钥存放在证书中，只要证书可信，公钥则可信")]),v._v(" "),_("li",[v._v("对称加密，减少加密运算消耗时间")])]),v._v(" "),_("p",[v._v("协议过程(步骤 1 和 2 为握手阶段)")]),v._v(" "),_("ol",[_("li",[v._v("客户端向服务端索要并验证公钥")]),v._v(" "),_("li",[v._v("客户端与服务端协商生成对话密钥")]),v._v(" "),_("li",[v._v("客户端与服务端采用对话密钥加密通信")])]),v._v(" "),_("p",[v._v("握手阶段(通信为明文传输)")]),v._v(" "),_("ol",[_("li",[v._v("客户端向服务端发出加密通信请求，ClientHello 请求\n"),_("ul",[_("li",[v._v("协议版本")]),v._v(" "),_("li",[v._v("客户端生成的随机数")]),v._v(" "),_("li",[v._v("支持的加密方法")]),v._v(" "),_("li",[v._v("支持的压缩方法")])])]),v._v(" "),_("li",[v._v("服务端接收请求后向客户端回应，ServerHello 响应\n"),_("ul",[_("li",[v._v("确认使用的协议版本(若与客户端不一致，服务端关闭加密通信)")]),v._v(" "),_("li",[v._v("服务端生成的随机数")]),v._v(" "),_("li",[v._v("确认使用的加密方法")]),v._v(" "),_("li",[v._v("服务器证书")])])]),v._v(" "),_("li",[v._v("客户端收到响应后验证证书并获取公钥，随后向服务器发送请求\n"),_("ul",[_("li",[v._v("随机数(又称 pre-master key)，用于服务器公钥加密，防止被窃听")]),v._v(" "),_("li",[v._v("编码通知，决定加密方法和密钥")]),v._v(" "),_("li",[v._v("客户端握手结束通知，其值为之前内容的 hash 值，供服务端校验")])])]),v._v(" "),_("li",[v._v("服务端接收到请求后，根据上述三个随机数生成会话密钥，之后发送\n"),_("ul",[_("li",[v._v("编码通知")]),v._v(" "),_("li",[v._v("服务端握手结束通知，值为内容 hash，共客户端校验")])])])]),v._v(" "),_("p",[v._v("流程梳理")]),v._v(" "),_("ol",[_("li",[v._v("客户端 -- client hello --\x3e 服务端")]),v._v(" "),_("li",[v._v("服务端 -- 证书(公钥) --\x3e 客户端")]),v._v(" "),_("li",[v._v("客户端(获取证书公钥) -- 公钥加密信息 --\x3e 服务端")]),v._v(" "),_("li",[v._v("服务端(私钥解密信息) -- 生成会话密钥 --\x3e 客户端")]),v._v(" "),_("li",[v._v("后续服务端与客户端使用会话密钥进行加密解密通信(对称加密)")])]),v._v(" "),_("h2",{attrs:{id:"http-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-2"}},[v._v("#")]),v._v(" HTTP 2")]),v._v(" "),_("p",[v._v("HTTP 2 进一步优化了通信性能，并解决了 1.1 中对头阻塞等问题")]),v._v(" "),_("ul",[_("li",[v._v("二进制分帧：引入头信息帧和数据帧")]),v._v(" "),_("li",[v._v("请求优先级：可以设置数据帧优先级，优化处理顺序")]),v._v(" "),_("li",[v._v("多路复用：用于解决队头阻塞问题")]),v._v(" "),_("li",[v._v("头部压缩：用于优化 Header 信息占比过重的请求 ("),_("code",[v._v("HPACK")]),v._v(" 算法)")]),v._v(" "),_("li",[v._v("服务端推送：允许服务端主动向客户端推送")])]),v._v(" "),_("h3",{attrs:{id:"二进制分帧"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二进制分帧"}},[v._v("#")]),v._v(" 二进制分帧")]),v._v(" "),_("p",[v._v("帧：报文被拆分为二进制帧，帧作为最小通信单位，承载特定类型的数据(Header 帧、Data 帧) "),_("br"),v._v("\n消息：HTTP 消息(请求、响应)由一个或多个帧组成 "),_("br"),v._v("\n流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数 ID。 "),_("br")]),v._v(" "),_("p",[v._v("对于相同 Stream ID 帧是有序传输的 "),_("br"),v._v("\n对于不同 Stream ID 帧是无序传输的 "),_("br"),v._v("\n接收到二进制帧后将对相同 Stream ID 的帧进行组装 "),_("br"),v._v("\n帧中包含着优先级、流量控制等信息，便于优化处理效率")]),v._v(" "),_("h3",{attrs:{id:"头部压缩"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#头部压缩"}},[v._v("#")]),v._v(" 头部压缩")]),v._v(" "),_("p",[v._v("采用"),_("a",{attrs:{href:"https://blog.csdn.net/u010129119/article/details/79392545",target:"_blank",rel:"noopener noreferrer"}},[v._v("HPACK"),_("OutboundLink")],1),v._v("算法进行压缩，主要包括")]),v._v(" "),_("ul",[_("li",[v._v("常用头信息规则映射")]),v._v(" "),_("li",[v._v("哈弗曼编码压缩数据")])]),v._v(" "),_("h3",{attrs:{id:"多路复用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多路复用"}},[v._v("#")]),v._v(" 多路复用")]),v._v(" "),_("p",[v._v("可以使用单一 TCP 连接发送多个请求，数据流以消息形式发送，消息由帧组成，帧首部添加了流标识，可以无序发送，由接收方组装，从而解决 1.1 中对头阻塞的问题。")]),v._v(" "),_("h3",{attrs:{id:"服务端推送"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#服务端推送"}},[v._v("#")]),v._v(" 服务端推送")]),v._v(" "),_("p",[v._v("服务端可以在接收客户端请求后，主动推送其他资源，客户端后续发送请求时若存在相关资源则可以直接通过缓存读取")])])}),[],!1,null,null,null);_.default=a.exports}}]);